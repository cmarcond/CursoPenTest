\begin{comment}
PYTHON

##########################################
Porque Python?
1. Praticidade
2. Comunidade
3. Legibilidade
4. Adaptabilidade
5. Velocidade

##########################################
Introdução a Python
1. Variáveis
2. Strings
3. Listas
4. Dicionários
5. Networking
7. Exceções
8. Funções
9. Iterações
10. Arquivo
11. Sys
12. OS

##########################################
1. Variáveis
Em Python toda variável é tratada como objeto e pode ser utilizada para gravar qualquer valor, desde reais, Booleans, strings e outras estruturas de dados mais complexas.
Ex:
>>> port = 21
>>> banner = "Wicket FTP server"
>>> print "[+] Verificando "+banner+" para a porta "+str(port)
[+] Checando Wicket FTP server para a porta 21

##########################################
2. Strings
A string Python possui diversos métodos/funções robustos para strings. É preferível olhar a documentação para uma visão mais ampla do contexto. Dentre elas temos: upper(), lower(), replace() e find().
Ex:
>>> banner = "Wicket FTP server"
>>> print banner.upper()
WICKET FTP SERVER
>>> print banner.lower()
wicket ftp server
>>> print banner.replace('Wicket', 'Ola')
Ola FTP server
>>> print banner.find('FTP')
10

##########################################
3. Listas
A estrutura de listas serve para guardar diversos objetos. Elas podem ser construidas a partir de qualquer tipo de dado e assim como strings possuem diversos métodos que facilitam seu uso.
Ex:
>>> portList = []
>>> portList.append(21)
>>> portList.append(80)
>>> portList.append(25)
>>> print portList
[21, 80, 25]
>>> portList.sort()
[21, 25, 80]

##########################################
4. Dicionarios
Dicionários são hash tables que podem guardar qualquer número de objetos de qualquer tipo. Ele armazena os objetos com uma chave e o objeto em si.
Ex:
>>> services = {'ftp':21, 'ssh':22}
>>> services.keys()
['ftp', 'ssh']
>>> services.items()
[('ftp', 21), ('ssh', 22)]
>>> services.has_key('ftp')
True
>>> services['ftp']
21

##########################################
5. Networking
O módulo de socket fornece uma biblioteca para fazer conexões de rede. Diferente de outras linguagens todo o processo de conexão e criação de sockets é automatizado e de simples uso.
Ex:
>>> import socket
>>> socket.setdefaulttimeout(2)
>>> s = socket.socket()
>>> s.connect(("192.0.0.1", 21))
>>> ans = s.recv(1024)
>>> if("Wicket FTP server" in ans):
        print "[+] Wicket FTP server is on"
    else:
        print "[+] Wicket FTP server is off"
[+] Wicket FTP server is off

##########################################
6. Exceção
Exceções possibilitam o programador rastrear um erro que não foi previsto em código, mesmo com o código correto isto pode acontecer devido a imprevistos, em exemplos futuros isso vai ser demonstrado mais amplamente.
Ex:
>>> try:
        print "[+] 1337/0 = "+ str(1337/0)
    except:
        print "[-] Error"
[-] Error        

##########################################
7. Funções
Assim como em outras linguagens Python possibilita a definição de funções que facilitam o uso de um código que se repete durante a execução do programa diminuindo quantidade de linhas e fornecendo legibilidade do código.
Ex:
def printName():
    print "Ola"
    
Se invocarmos a função com "printName()" durante o código Ola sera printado.

##########################################
9. Iteração
Python também possui loops.
Ex:
>>> for x in  range(1, 2555):
        print str(x)
1
2
3
4
...

##########################################
10. Arquivo
Também é possível salvar e ler arquivos em disco.


##########################################
11. Sys
O modulo Sys nativo fornece acesso a objetos utilizados e mantidos pelo interpretador da linguagem. Isso inclui flags, versão, tamanho máximo de variáveis, módulos e etc.
Ex:
import sys
if len(sys.argv)==2:
    print "Temos dois argumentos"
    print sys.argv[1]
    print sys.argv[2]

##########################################
12. OS
O modulo OS nativo da linguagem oferece diversas rotinas para os sistemas operacionais Mac, NT ou Posix. Esse modulo possibilita interação com o OS em campos como o sistema de arquivos, banco de usuários, permissões, etc.
Ex:
import sys
import os

if len(sys.argv)==2:
    filename = sys.argv[1]
    if not os.path.isfile(filename):
        print "[-] Caminho do arquivo está errado"
        exit(0)
    if not os.access(filename, os.R_OK)
        print "[-] " + filename + " não está aberto para leitura"
        exit(0)

##########################################
Bibliotecas:
crypt -> Permite encriptar uma palavra.

##########################################
Clifford Stoll que foi um administrador de sistemas na Lawrence Berkley National Labs documentou uma caça a um hacker (que era membro da KGB) que quebrou diversos laboratórios, bases militares, universidades e outros no livro "The Cuckoo's Egg: Tracking a Spy Through the Maze of Computer Espionage". Ele também escreveu um artigo sobre os detalhes técnicos do ataque e da caça.

##########################################
Stoll conectou uma impressora a um servidor após descobrir o hacker e abriu um server para o ataque a fim de atrai-lo para a armadilha. Assim toda tecla pressionada pelo hacker era devidamente documentada. O espião recuperava o arquivo da senha guardada, mas como isso era útil se todas eram encriptadas pelo sistema UNIX? Foi então que ao acessar o log do hacker ele conseguiu a informação das vitimas e decidiu estudar as senhas, foi então que ele percebeu que quase todas as senhas eram compostas de palavras comuns facilmente encontradas no dicionário.

##########################################
UNIX Password Cracker

Ex de arquivo:
victim: HX9LLTdc/jiDE: 503:100:Iama Victim:/home/victim:/bin/sh
root: DFNFxgW7C05fo: 504:100: Markus Hess:/root:/bin/bash

import crypt
def testPass(cryptPass):
    salt = cryptPass[0:2]
    dictFile = open('dictionary.txt', 'r')
    for word in dictFile.readlines():
        word = word.strip('\n')
        cryptWord = crypt.crypt(word, salt)
        if(cryptWord == cryptPass):
            print "[+] Foooound it! ->" + word + "\n"
            return
    print "[-] No success"

def main():
    passFile = open('passwords.txt')
    for line in passFile.readlines():
        if ":" in line:
            user = line.split(':')[0]
            cryptPass = line.split(':')[1].strip(' ')
            print "[*] Cracking Password for: "+user
            testPass(cryptPass)
if __name__ == "__main__":
    main()
    
##########################################
Port Scanner
Informação e reconhecimento da área são os pontos mais importantes de guerra. Em caso de conflito real são enviados abatedores com cavalos a fim de descubrir vulnerabilidades em um castelo ou cidade. Em segurança de redes devemos verificar as portas da rede, para isso começaremos com um algoritmo simples para escanear as portas de um IP específico.

##########################################
Port Scanner
Python, assim como a maior parte das linguagens modernas, oferece acesso a interface BSD de sockets. Essa interface torna possível a construção de aplicações para comunicação de rede entre hosts. Com uma série de diversas funções da API é possível criar e comunicar através de sockets TCP/IP com as operações básicas de create, bind, listen, send e connect.

##########################################
Port Scanner
A maior parte da internet é acessível através de TCP. Por exemplo, o local de teste e estudo pode ter um web server em TCP na porta 80, servidor de emails na porta 25, server de arquivos na porta 21, assim por diante. Para se conectar a esses serviços é necessário tanto o IP quanto a porta do serviço. Apesar de alguém envolvido com esse local ter acesso a essas informações é provável que o attacker não saiba.

##########################################
Port Scanner
Um attacker executa diversos port scanner no ínicio de todo ataque. Um tipo inclui enviar um pacote TCP SYN para uma série de portas comuns e esperar a resposta TCP ACK que vai sinalizar o status da porta. Um TCP Connect Scan usa three-way handshake para determinar a conexão. Utilizaremos TCP full connect scan para identificar os hosts.

##########################################
Port Scanner
Para entender melhor esse algoritmo foi divido em cinco passos e escrever o código gradualmente. Primeiro utilizaremos uma lista com o hostname e a porta separados por ";", depois traduziremos o hostname para um endereço de Internet IPv4. Para cada porta da lista iremos conectar com o endereço alvo da porta específica. Finalmente, para conseguir saber o serviço da porta, enviaremos lixo e receberemos o resultado do banner.

##########################################
Port Scanner
Primeiro Passo:
Receber hostname e usuário inseridos pelo usuário. Para isso usaremos a biblioteca optparse para fazer o parsing das opções de linha de comando. OptionParser([usage message]) cria uma instância de um option parser. Em seguida, parser.add_option especifica os comandos individuais para o script.

##########################################
Port Scanner
FOTO ALGORITMO 1
//EXPLICAR CONNSCAN E PORTSCANN MAIS A FUNCAO MAIN E O OPTPARSE

##########################################
Nmap Port Scanner
O toolkit Nmap oferece a possibilidade de fazer diferentes tipos de scan como ACK, RST, FIN ou SYN-ACK. Isso é necessário para não limitarmos nossa busca em apenas um tipo específico de scan.

##########################################
Nmap Port Sacnner
FOTO ALGORITMO 2
//EXPLICAR PortScanner(), scan() etc

##########################################
SSH Botnet
Agora que temos um port sacnner para encontrar alvos, podemos começar a estudar as vulnerabilidades de cada serviço. O objetivo do botnet é forçar entrada pelo SSHe para isso precisamos interagir com o shell usando a biblioteca Pexpect que possibilita estudar outputs a inserir inputs relativo com o que o shell espera.

##########################################
SSH Access
FOTO ALGORITMO 3
//explicar child.expect(), session.expect()

##########################################
SSH Access Brute Force
Agora que entendemos como utilizar o Pexpect podemos simplificar o script com PXSSH. PXSSH é uma biblioteca que é uma evolução que especializa o uso de Pexpect com funções pre-definidas como login(), logout(), prompt() e etc.

##########################################
SSH Access Brute Force
FOTO ALGORITMO 4

##########################################
SSH Through Debian Exploit
Em 2006 a distribuição Debian do Linux teve uma linha de seu código comentada por engano por umd esenvolvedor. Essa linha garantia a entropia durante o processo de criação de chaves SSH. Esse comentário limitou o espaço de criação das chaves para 15-bits de entropia. Isso significa que 32,767 chaves existiam para cada algoritmo e tamanho. Em 2 horas foi possível gerar todas as chaves. As chaves podem ser encontradas facilmente na internet e com elas que iremos trabalhar.

##########################################
SSH Through Debian Exploit
FOTO ALGORITMO 5

##########################################
SSH Botnet 
Agora finalmente podemos construir nosso botnet unindo o que foi anteriormente apresentado e simplificando o código com o uso de classes. Podemos expandir o controle do algoritmo para multiplos hosts possibilitando o uso de diversas máquinas em um ataque.

##########################################
SSH Botnet
FOTO ALGORITMO 6

##########################################
Anonymous FTP Scanner
Considerando os problemas de segurança que isso pode trazer, seria surreal que sites ofereçam acesso anonimo FTP. Porém diversos sites seguem com essa filosofia pela facilidade de atualizar softwares. Iremos utilizar a biblioteca ftplib afim de cosntruir um script que determina se um servidor oferece login anonimo. A função anonLogin() recebe o hostname e retorna um boolean que indica a possibilidade desse login. 

##########################################
Anonymous FTP Scanner
FOTO ALGORITMO 7

##########################################
Anonymous Brute Force FTP User Credentials
Agora podemos avançar com esse script e melhora-lo para descobrir e ganhar acesso ao servidor através de força bruta. Iremos escrever a função bruteLogin() para isso, a função ira receber o hostname e um arquivo de senhas como input e retornar as credenciais que possibilitam acesso ao host.

##########################################
Anonymous Brute Force FTP User Credentials
FOTO ALGORITMO 8

##########################################
Searching for Web Pages with FTP Server
Agora que conseguimos as credenciais o próximo passo é verificar se o server oferece acesso a web. Para testar isso devemos listar o conteúdo do diretório do server e procurar pela existência de páginas default. A função returnDefault() recebe uma conexão FTP e retorna um array com as páginas default que encontrar.

##########################################
Searching for Web Pages with FTP Server
FOTO ALGORITMO 9 
//EXPLICAR NLST

##########################################
Malicious Inject to Web Pages
Agora que encontramos as páginas de web devemos infecta-las com um redirect. No exemplo fornecido utilizamos o framework Metasploit para criar um servidor com uma página hosteada em http://10.10.10.112:8080/exploit. O serviço oferece o exploit ms10_002_aurora, que é o mesmo exploit utilizado contra o Google na Oepração Aurora.
Se for bem sucedido um TCP shell reverso será criado garantindo acesso ao cmd do Windows.

##########################################
Malicious Inject to Web Pages
FOTO ALGORITMO 10

##########################################
Bringing All Together
Agora iremos unir o ataque inteiro em um unico script que automatizara todo o processo.

##########################################
Bringing All Together
FOTO ALGORITMO 11 - attack()

##########################################
Bringing All Together
FOTO ALGORITMO 11 - Partes 1 2 e 3

##########################################
Conficker
Em 2008 um worm chamou a atenção de diversos especialistas pela sua influência na rede. O worm conseguiu infectar rapidamente mais de 5 milhões de máquinas em mais de 200 paises. Enquanto algumas técnicas avançadas colaboraram para seu sucesso (assinaturas digitais, payloads encriptadas e esquemas de propagação alternativos) o Conficker possui algumas similiaridades ao Worm de Morris.

##########################################
Conficker
Similiaridades:
1. Conficker usa um arquivo com 250 senhas comuns enquanto o Worm de Morris utiliza uma lista com 432 senhas. Dentre esses passwords 12 são os mais frequentes e definitivamente válidos para inclusão em qualquer ataque: aaa, academia, anything, coffee, computer, cookie, oracle, password, secret, super, unknown, admin
2. 

\end{comment}